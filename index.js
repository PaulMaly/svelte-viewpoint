(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('svelte/internal')) :
	typeof define === 'function' && define.amd ? define(['svelte/internal'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Viewpoint = factory(global.internal));
}(this, (function (internal) { 'use strict';

	/* src/Viewpoint.svelte generated by Svelte v3.29.0 */

	const get_error_slot_changes = dirty => ({ error: dirty & /*$$restProps, load*/ 144 });
	const get_error_slot_context = ctx => ({ error: /*error*/ ctx[15] });
	const get_loading_slot_changes = dirty => ({});
	const get_loading_slot_context = ctx => ({});
	const get_waiting_slot_changes = dirty => ({});
	const get_waiting_slot_context = ctx => ({});

	// (11:0) {:catch error}
	function create_catch_block(ctx) {
		let current;
		const error_slot_template = /*#slots*/ ctx[13].error;
		const error_slot = internal.create_slot(error_slot_template, ctx, /*$$scope*/ ctx[12], get_error_slot_context);

		return {
			c() {
				if (error_slot) error_slot.c();
			},
			m(target, anchor) {
				if (error_slot) {
					error_slot.m(target, anchor);
				}

				current = true;
			},
			p(ctx, dirty) {
				if (error_slot) {
					if (error_slot.p && dirty & /*$$scope, $$restProps, load*/ 4240) {
						internal.update_slot(error_slot, error_slot_template, ctx, /*$$scope*/ ctx[12], dirty, get_error_slot_changes, get_error_slot_context);
					}
				}
			},
			i(local) {
				if (current) return;
				internal.transition_in(error_slot, local);
				current = true;
			},
			o(local) {
				internal.transition_out(error_slot, local);
				current = false;
			},
			d(detaching) {
				if (error_slot) error_slot.d(detaching);
			}
		};
	}

	// (7:0) {:then comp}
	function create_then_block(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*comp*/ ctx[14] && create_if_block_2(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = internal.empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				internal.insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (/*comp*/ ctx[14]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*$$restProps, load*/ 144) {
							internal.transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_2(ctx);
						if_block.c();
						internal.transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					internal.group_outros();

					internal.transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					internal.check_outros();
				}
			},
			i(local) {
				if (current) return;
				internal.transition_in(if_block);
				current = true;
			},
			o(local) {
				internal.transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (if_block) if_block.d(detaching);
				if (detaching) internal.detach(if_block_anchor);
			}
		};
	}

	// (8:1) {#if comp}
	function create_if_block_2(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;
		const switch_instance_spread_levels = [/*$$restProps*/ ctx[7], /*state*/ ctx[1]];
		var switch_value = /*comp*/ ctx[14];

		function switch_props(ctx) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = internal.assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = new switch_value(switch_props());
		}

		return {
			c() {
				if (switch_instance) internal.create_component(switch_instance.$$.fragment);
				switch_instance_anchor = internal.empty();
			},
			m(target, anchor) {
				if (switch_instance) {
					internal.mount_component(switch_instance, target, anchor);
				}

				internal.insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const switch_instance_changes = (dirty & /*$$restProps, state*/ 130)
				? internal.get_spread_update(switch_instance_spread_levels, [
						dirty & /*$$restProps*/ 128 && internal.get_spread_object(/*$$restProps*/ ctx[7]),
						dirty & /*state*/ 2 && internal.get_spread_object(/*state*/ ctx[1])
					])
				: {};

				if (switch_value !== (switch_value = /*comp*/ ctx[14])) {
					if (switch_instance) {
						internal.group_outros();
						const old_component = switch_instance;

						internal.transition_out(old_component.$$.fragment, 1, 0, () => {
							internal.destroy_component(old_component, 1);
						});

						internal.check_outros();
					}

					if (switch_value) {
						switch_instance = new switch_value(switch_props());
						internal.create_component(switch_instance.$$.fragment);
						internal.transition_in(switch_instance.$$.fragment, 1);
						internal.mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) internal.transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) internal.transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) internal.detach(switch_instance_anchor);
				if (switch_instance) internal.destroy_component(switch_instance, detaching);
			}
		};
	}

	// (1:77)   {#if timeout && !timeoutTimer}
	function create_pending_block(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block, create_if_block_1];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*timeout*/ ctx[0] && !/*timeoutTimer*/ ctx[2]) return 0;
			if (!/*delayTimer*/ ctx[3]) return 1;
			return -1;
		}

		if (~(current_block_type_index = select_block_type(ctx))) {
			if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		}

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = internal.empty();
			},
			m(target, anchor) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].m(target, anchor);
				}

				internal.insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if (~current_block_type_index) {
						if_blocks[current_block_type_index].p(ctx, dirty);
					}
				} else {
					if (if_block) {
						internal.group_outros();

						internal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
							if_blocks[previous_block_index] = null;
						});

						internal.check_outros();
					}

					if (~current_block_type_index) {
						if_block = if_blocks[current_block_type_index];

						if (!if_block) {
							if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
							if_block.c();
						}

						internal.transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					} else {
						if_block = null;
					}
				}
			},
			i(local) {
				if (current) return;
				internal.transition_in(if_block);
				current = true;
			},
			o(local) {
				internal.transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].d(detaching);
				}

				if (detaching) internal.detach(if_block_anchor);
			}
		};
	}

	// (4:23) 
	function create_if_block_1(ctx) {
		let current;
		const loading_slot_template = /*#slots*/ ctx[13].loading;
		const loading_slot = internal.create_slot(loading_slot_template, ctx, /*$$scope*/ ctx[12], get_loading_slot_context);

		return {
			c() {
				if (loading_slot) loading_slot.c();
			},
			m(target, anchor) {
				if (loading_slot) {
					loading_slot.m(target, anchor);
				}

				current = true;
			},
			p(ctx, dirty) {
				if (loading_slot) {
					if (loading_slot.p && dirty & /*$$scope*/ 4096) {
						internal.update_slot(loading_slot, loading_slot_template, ctx, /*$$scope*/ ctx[12], dirty, get_loading_slot_changes, get_loading_slot_context);
					}
				}
			},
			i(local) {
				if (current) return;
				internal.transition_in(loading_slot, local);
				current = true;
			},
			o(local) {
				internal.transition_out(loading_slot, local);
				current = false;
			},
			d(detaching) {
				if (loading_slot) loading_slot.d(detaching);
			}
		};
	}

	// (2:1) {#if timeout && !timeoutTimer}
	function create_if_block(ctx) {
		let current;
		const waiting_slot_template = /*#slots*/ ctx[13].waiting;
		const waiting_slot = internal.create_slot(waiting_slot_template, ctx, /*$$scope*/ ctx[12], get_waiting_slot_context);

		return {
			c() {
				if (waiting_slot) waiting_slot.c();
			},
			m(target, anchor) {
				if (waiting_slot) {
					waiting_slot.m(target, anchor);
				}

				current = true;
			},
			p(ctx, dirty) {
				if (waiting_slot) {
					if (waiting_slot.p && dirty & /*$$scope*/ 4096) {
						internal.update_slot(waiting_slot, waiting_slot_template, ctx, /*$$scope*/ ctx[12], dirty, get_waiting_slot_changes, get_waiting_slot_context);
					}
				}
			},
			i(local) {
				if (current) return;
				internal.transition_in(waiting_slot, local);
				current = true;
			},
			o(local) {
				internal.transition_out(waiting_slot, local);
				current = false;
			},
			d(detaching) {
				if (waiting_slot) waiting_slot.d(detaching);
			}
		};
	}

	function create_fragment(ctx) {
		let await_block_anchor;
		let promise;
		let current;

		let info = {
			ctx,
			current: null,
			token: null,
			hasCatch: true,
			pending: create_pending_block,
			then: create_then_block,
			catch: create_catch_block,
			value: 14,
			error: 15,
			blocks: [,,,]
		};

		internal.handle_promise(promise = (/*$$restProps*/ ctx[7], Promise.resolve().then(/*wait*/ ctx[6]).then(/*load*/ ctx[4]).then(/*preload*/ ctx[5])), info);

		return {
			c() {
				await_block_anchor = internal.empty();
				info.block.c();
			},
			m(target, anchor) {
				internal.insert(target, await_block_anchor, anchor);
				info.block.m(target, info.anchor = anchor);
				info.mount = () => await_block_anchor.parentNode;
				info.anchor = await_block_anchor;
				current = true;
			},
			p(new_ctx, [dirty]) {
				ctx = new_ctx;
				info.ctx = ctx;

				if (dirty & /*$$restProps, load*/ 144 && promise !== (promise = (/*$$restProps*/ ctx[7], Promise.resolve().then(/*wait*/ ctx[6]).then(/*load*/ ctx[4]).then(/*preload*/ ctx[5]))) && internal.handle_promise(promise, info)) ; else {
					const child_ctx = ctx.slice();
					child_ctx[14] = child_ctx[15] = info.resolved;
					info.block.p(child_ctx, dirty);
				}
			},
			i(local) {
				if (current) return;
				internal.transition_in(info.block);
				current = true;
			},
			o(local) {
				for (let i = 0; i < 3; i += 1) {
					const block = info.blocks[i];
					internal.transition_out(block);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) internal.detach(await_block_anchor);
				info.block.d(detaching);
				info.token = null;
				info = null;
			}
		};
	}

	function instance($$self, $$props, $$invalidate) {
		const omit_props_names = ["component","preloading","delay","timeout","abort"];
		let $$restProps = internal.compute_rest_props($$props, omit_props_names);
		let { $$slots: slots = {}, $$scope } = $$props;

		let { component = null } = $$props,
			{ preloading = true } = $$props,
			state = null,
			timeoutTimer,
			delayTimer,
			{ delay = 200 } = $$props,
			{ timeout = 0 } = $$props,
			{ abort = 0 } = $$props;

		function preload(m) {
			return m && Promise.resolve(preloading && typeof m.preload === "function"
			? m.preload($$restProps)
			: undefined).then((data = {}) => {
				$$invalidate(1, state = data);
				return m.default || m;
			});
		}

		function wait() {
			delay && $$invalidate(3, delayTimer = setTimeout(
				() => {
					$$invalidate(3, delayTimer = clearTimeout(delayTimer));
				},
				delay
			));

			timeout && $$invalidate(2, timeoutTimer = setTimeout(
				() => {
					$$invalidate(2, timeoutTimer = clearTimeout(timeoutTimer));
				},
				timeout
			));
		}

		$$self.$$set = $$new_props => {
			$$props = internal.assign(internal.assign({}, $$props), internal.exclude_internal_props($$new_props));
			$$invalidate(7, $$restProps = internal.compute_rest_props($$props, omit_props_names));
			if ("component" in $$new_props) $$invalidate(8, component = $$new_props.component);
			if ("preloading" in $$new_props) $$invalidate(9, preloading = $$new_props.preloading);
			if ("delay" in $$new_props) $$invalidate(10, delay = $$new_props.delay);
			if ("timeout" in $$new_props) $$invalidate(0, timeout = $$new_props.timeout);
			if ("abort" in $$new_props) $$invalidate(11, abort = $$new_props.abort);
			if ("$$scope" in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
		};

		let load;

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*component, abort*/ 2304) {
				 $$invalidate(4, load = function () {
					return new Promise((resolve, reject) => {
							let abortTimer;

							Promise.resolve(typeof component === "function" && !(/^\s*class\s+/).test(component.toString())
							? component()
							: component).then(m => {
								clearTimeout(abortTimer); // class, not a plain function
								resolve(m);
							});

							abort && (abortTimer = setTimeout(
								() => {
									reject(new Error("Aborted by timeout."));
								},
								abort
							));
						});
				});
			}
		};

		return [
			timeout,
			state,
			timeoutTimer,
			delayTimer,
			load,
			preload,
			wait,
			$$restProps,
			component,
			preloading,
			delay,
			abort,
			$$scope,
			slots
		];
	}

	class Viewpoint extends internal.SvelteComponent {
		constructor(options) {
			super();

			internal.init(this, options, instance, create_fragment, internal.safe_not_equal, {
				component: 8,
				preloading: 9,
				delay: 10,
				timeout: 0,
				abort: 11
			});
		}
	}

	return Viewpoint;

})));
